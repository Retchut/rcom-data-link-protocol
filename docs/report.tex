\documentclass[11pt]{article}

\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[margin=3.9cm]{geometry}
\graphicspath{{./images/}}

\title{\includegraphics[scale=0.3]{logo.png} \\ \textbf{Data Link Protocol}}
\author{Computer Networks\\ Bachelors in Informatics and Computing Engineering \\ \\ 3LEIC03\_G3 \\ \\ Tiago
Rodrigues up201907021@fe.up.pt \\ MÃ¡rio Travassos up201905871@fe.up.pt  }
\date{\today}

\begin{document}

\maketitle

\newpage

\section*{Summary}

\paragraph{}This report will cover the first work proposed for the Computer Networks Curricular Unit, with
the objective of creating a small application that could transfer data through two computers asynchronously,
through a serial port.

\paragraph{}The application is capable of transferring files whilst mainting their integrity, and detect
errors in transmission, resolving them if possible.

\section*{Introduction}

\paragraph{}This report is the result of an examination to the practical component, which was the
development of a data transfer protocol. A serial port was used to transfer the files in an asynchronous
fashion.

The report is organized as follows:

\begin{enumerate}
  \item{Architecture- Functional blocks and interfaces}
  \item{Code Structure - APIs, main code structures and their relation with the architecture}
  \item{Main use cases - Identification and Call Stack Sequence}
  \item{Data link Protocol - Main functional aspects and implementation strategy}
  \item{Application Protocol - Main functional aspects and implementation strategy }
  \item{Validation - Description of the tests conducted}
  \item{Efficiency - Statistical characterization of efficiency, against a Stop\&Wait protocol}
  \item{Conclusion - Summary of the above descriptions, reflection on the learning objectives}
\end{enumerate}

\section{Architecture}

The application consists of two main layers, one to interact with the file to be sent and another to
interact with the hardware. They are the Application Layer, and the Data-Link Layer, and they are detailed
below.

\subsection{Application Layer}

\paragraph{}This layer can be found in the \textbf{rcom-ftp.c} file, and it encompasses everything related
to interaction with the files, be it opening, closing, reading and writing to and from it. Besides that,
this is the layer through which the user interacts with the application.

\subsection{Data-Link Layer}

\paragraph{}This layer can be found in the \textbf{ll.c} file and it is responsible for ensuring a smooth
data transmission over the hardware, including opening, closing, writing and reading from the serial port,
with the help of the auxiliary functions present in \textbf{config.c}, \textbf{read.c}, \textbf{send.c},
\textbf{state.c} and \textbf{utils.c}.

\section{Code Structure}

\paragraph{}The code is divided into seven source code files, separated by responsibility (reading from or
writing to the serial port), and by layer. Also, each of them has a corresponding header file. Finally,
there is a dedicated header file that hosts several common constants.

\subsection{Application - rcom-ftp.c}

\paragraph{}This module contains the entire application layer developed.

\paragraph{Main Functions}

\begin{itemize}
        \item{main - Interacts with the user and passes the arguments given to the rest of the program.}
        \item{sendFile - Sends the file requested by the user.}
        \item{readFile - Retrieves the file sent by the user.}
\end{itemize}

\paragraph{Main Data Structures}

\begin{itemize}
        \item{fileData - Responsible for holding some metadata of the file.}
\end{itemize}

\subsection{Config - config.c}

\paragraph{}This module contains the functions required for setting up the serial port for proper file
transferring.

\paragraph{Main Functions}

\begin{itemize}
        \item{set\_config - Sets up the initial configuration for the serial port.}
        \item{reset\_config - Restores the serial port to its initial state.}
\end{itemize}

\subsection{Link Layer - ll.c}

\paragraph{}This module contains the interface for the Link Layer of the protocol.

\paragraph{Main Functions}

\begin{itemize}
        \item{llopen - Opens the serial port from frame transmission.}
        \item{llwrite - Writes a frame to the serial port.}
        \item{llread - Reads a frame from the serial port and checks its integrity.}
        \item{llclose - Closes the serial port after communication ceases.}
\end{itemize}

\subsection{Reading - read.c}

\paragraph{}This module contains the functions responsible for reading from the serial port.

\paragraph{Main Functions}

\begin{itemize}
  \item{readSupervisionFrame - Reads a supervision frame and checks if the information is received
        correctly.}
  \item{readInformationMessage - Reads an information message and saves the data, which includes the
        BCC, in a buffer.}
\end{itemize}

\subsection{Writing - send.c}

\paragraph{}This module contains the functions responsible for writing to the serial port.

\paragraph{Main Functions}

\begin{itemize}
  \item{writeSupervisionAndRetry - Attempts to write a supervision Frame in 3 attempts. If it
        succeeds, it stops.}
  \item{writeInformationAndRetry - Attempts to write an information Frame in 3 attempts. If it
        succeeds, it stops.}
\end{itemize}

\subsection{State Management - state.c}

\paragraph{}This module contains the functions responsible for managing the state of the application.

\paragraph{Main Functions}

\begin{itemize}
  \item{handle\_state - Function responsible for managing the state of the application, according to
        the data received.}
\end{itemize}

\paragraph{Main Data Structures}

\begin{itemize}
        \item{state\_t - Enumeration containing the possible states of the application.}
  \item{state\_machine - Besides the state of the machine, holds some of the main pieces of
        information from each frame.}
\end{itemize}

\subsection{Utilities - utils.c}

\paragraph{}This module contains some auxiliary functions that help the others with their operations.

\paragraph{Main Functions}

\begin{itemize}
        \item{stuff\_data - This functions stuffs the data given.}
        \item{unstuff\_frame - This functions unstuffs the frame given.}
\end{itemize}

\subsection{Constants - defines.h}

\paragraph{}This module contains some of the more meaningful constants shared throughout the application.

\section{Main use cases}

\paragraph{}The application should be first compiled with the provided Makefile, by running
\verb|make clean && make|. Then, if we are the receiver, we run \verb|./rcom-ftp receiver <port>|, or, if we
are the emitter, \verb|./rcom-ftp emitter <port> <file>|, where port is the number of the port to be used,
which will be translated to \verb|/dev/ttyS<port>|, and file is the file to be sent over.

\paragraph{} When starting up the application, the receiver should be called first, otherwise the emitter
will be trying to connect for a total of 9 tries, making a stop of 1 second between each. If it can't
succeed in connecting, it will halt. Otherwise, the application layer will begin dividing the file into
packets, and sending to the receiver through the \textbf{llwrite} function, whilst the receiver is reading
with the \textbf{llread} one. Finally, both of them should call \textbf{llclose} in order to cease
transmission.

\section{The Data link Layer}

\paragraph{}This layer is responsible for interacting with the serial port, abstracting away the intricacies
using it, producing a consistent layer of work for the application. It uses several auxiliary functions, as
a way to better structure the code, assigning to each function a single responsibility. The main functions
are divided as follows:

\subsection*{llopen}

\paragraph{}The \textbf{llopen} function sets up the communication between the transmitter and receiver. It
start by configuring the serial for for proper reading and writing, setting the appropriate flags and
setting \textbf{VTIME} to 30 and \textbf{VMIN} to 0, which ensures the read function won't have to wait for
a character to return.

\paragraph{}After that, and according to the provided role, it will either send a \textbf{SET} command and
await for a \textbf{UA}, if it is the emitter, or wait for a \textbf{SET} command and then send a
\textbf{UA}, in the case of the transmitter. To do this, they take advantage of the
\verb|writeSupervisionAndRetry| and the \verb|readSupervisionFrame| functions, which, respectively, handle
writing to the serial port and reading from it, setting the appropriate state.

\subsection*{llwrite}

\paragraph{}As the name implies, the \textbf{llwrite} function writes a given packet of data to the serial
port. To do this, it calls the \verb|writeInformationAndRetry| function, which, through the use of
\verb|writeInformationFrame|, appends the frame header and trailer, and writes it to the serial port. It
retries if the writing is unsuccessful, a total of 3 times, point at which it returns with an error.
After a successful writing, it waits to receive a confirmation message, either accepting or rejecting the
frame. If it accepts, then the frame is written and \textbf{llwrite} halts. Otherwise, if it was rejected, then it
resends the same frame again, not increasing the attempts made (as writing was successful, but the message
got rejected). Finally, if some error occurred, it tries to resend the message until all tries all consumed.

\subsection*{llread}

\paragraph{}The workings of \textbf{llread} are similar to those of \textbf{llwrite}. First, it tries to read the incoming information message. When successfull, it then proceeds to unstuff the incoming frame and
check if the data has been corrupted. If it hasn't, then it acknowledges the packet, sending back a
\textbf{RR} frame, and if sent successfully, returns the size of the information read. When the data appears
to be corrupted, it sends a \textbf{REJ} frame, telling the emitter to retry sending that information.
Finally, if some error occurred, it returns with an error as well, ceasing transmission.

\subsection*{llclose}

\paragraph{}Finally, this function handles the cease of communication between the two computers. If the
caller is the emitter, it will start of by sending a \textbf{DISC} frame, telling the receiver it wishes to
stop communication. Then, it waits for a \textbf{DISC} response and sends a final \textbf{UA} frame before
terminating. The receiver works the other way around, first waiting for a \textbf{DISC} frame to be read,
then sending his \textbf{DISC}, and finally reading the \textbf{UA} before being able to shutdown. Both, in
case there is a problem with writing, try again for a total of 9 attempts, before exiting with error.

\section{The Application Layer}

\subsection*{sendFile}

\paragraph{}This is the main function that drives the emitter. It starts by retrieving the metadata from the
file, to make it easier to divide into equally sized packets. Afterwards, it generates a starter
packet that contains the metadata from the file, and proceeds to send out the file contents. Each packet
sent has a maximum size of 1024 bytes, which means that it will send 1024 byte packets for as long as
possible, and in the last one, it sends the leftover bytes that didn't reach 1024. Finally, it resends the
starter packet, but with a flag changed meaning that it will be end of the transmission. At each step, in
the event of a malfunction, it returns with an error.

\subsection*{receiveFile}

\paragraph{}On the other end, the \textbf{receiveFile} function is in charge of driving the receiver. It's
way of working is much like the one on \textbf{sendFile}. Firstly, it reads the starting packet containing
the metadata on the file. It then creates the new file, appending received to the start of the original
file name. Afterwards, it reads the packets containing information, one by one, and assembles the file after
each successfull packet receive. Finally, it reads the end Packet, which will tell the receiver to stop
trying to read any longer. Once again, if at any point the receiver detects an error reading any packet, it
will stop with an error.

\subsection*{generateDataPacket}

\paragraph{}This function creates the packets that will be sent over to the receiver. It starts by appending
the correct packet header, and then copies the information over to packet buffer, returning it.

\subsection*{readDataPacket}

\paragraph{}This function is analogous to the \textbf{generateDataPacket} one, and it's job is to read a
packet and check for its integrity after transmission. To do this, it starts by checking if the packet is in
fact a data packet, by verifying the first bit. Then it makes sure that the data packet received is not a
duplicate, aborting if it is. Finally, and if all goes well, it retrieves the information contained and saves
it in a buffer.

\section{Validation}

\paragraph{}In order to test the protocol, files of different sizes were sent, namely \textbf{pinguim.gif}
(10968 bytes) and testText.txt (2053 bytes). Also, the transmission was tested with timeouts
on the lab, and with introduction of random errors, by placing a bit of metal that would send erroneous bits
sometimes. All tests were verified by using the \textbf{md5sum} hashing function.

\section{Efficiency}

\paragraph{}As of the writing of this report, efficiency was not tested.

\section{Conclusion}

\paragraph{}The task assigned consisted in implementing a data transfer protocol to communicate over a serial
port. In this assignment, it was key to create distinct layers, and, more importantly, make sure they didn't
know each other's implementation. This lead to a structure in which the application layer, the ``highest''
section of the program, only knew what the data-link layer did, but not how it operated, and the data-link
knew only that it would receive data and would have to transmit it. This effectively creates two distinct
entities that in nothing influence each other, but work together for the objective of transmitting data.

\paragraph{}The project was completed successfully, and it contributed a great deal for a deepened knowledge
on how data is actually transferred, how errors in the data are handled, and how a file can almost magically
appear on another computer.

\end{document}
